{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#arquitetura-e-organizacao-de-computadores","title":"Arquitetura e Organiza\u00e7\u00e3o de Computadores","text":"<p>Material da parte pr\u00e1tica, a qual ministrei mais recentemente.</p> <p></p>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<ul> <li>Digital Design and Computer Architecture, RISC-V Edition</li> <li>From Blinker to RISC-V</li> <li>http://www.riscbook.com/portuguese/</li> <li>https://riscv-programming.org/</li> <li>https://www.riscvschool.com/</li> <li>https://menotti.pro.br/mm/</li> </ul>"},{"location":"labs/","title":"Parte pr\u00e1tica","text":""},{"location":"labs/#simulacoes","title":"Simula\u00e7\u00f5es","text":"<p>Em geral, as simula\u00e7\u00f5es funcionais podem todas ser realizada em ambiente Linux. A seguir est\u00e1 o comando de instala\u00e7\u00e3o, dependendo de sua distribui\u00e7\u00e3o, dos pacotes necess\u00e1rios: <code>[apt|snap|yum|rpm|dnf|pacman] install iverilog gtkwave gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu qemu-user qemu-user-static</code></p>"},{"location":"labs/#extensoes-uteis-para-o-vscode","title":"Extens\u00f5es \u00fateis para o VSCode","text":"<ul> <li>Verilog</li> <li>WaveTrave</li> <li>DigitalJS</li> <li>RISCV</li> </ul>"},{"location":"labs/#kit-de-fpga","title":"Kit de FPGA","text":"<p>Para sintetizar cada laborat\u00f3rio e fazer o download para a placa, digite <code>..\\make_wannabe.bat</code> (Windows) ou <code>make -f ../Makefile</code> (Linux) dentro do diret\u00f3rio do respectivo laborat\u00f3rio (n\u00e3o nesta pasta, pois os comandos fazem refer\u00eancia ao n\u00edvel superior). </p>"},{"location":"labs/#de0-cv","title":"DE0-CV","text":"<p>Consulte o manual do kit para compreender como usar cada recurso. Um arquivo de pinos \u00e9 usado para mapear as entradas e sa\u00eddas.</p>"},{"location":"labs/01-banner/","title":"Criando um banner no kit de FPGAs","text":"<p>Se voc\u00ea n\u00e3o se lembra de como usar o kit de FPGAs e as ferramentas, d\u00ea uma olhada neste laborat\u00f3rio.</p> <p>O objetivo desta pr\u00e1tica \u00e9 usar uma mem\u00f3ria ROM para criar um efeito visual que simule um banner nos LEDs do kit. O conte\u00fado da mem\u00f3ria \u00e9 exibido nos LEDs uma linha por vez, o que visto rapidamente, em movimento ou filmado pode revelar seu conte\u00fado completo se usada a frequ\u00eancia correta. </p> <p>Os arquivos est\u00e3o todos completos, voc\u00ea s\u00f3 precisa modificar o conte\u00fado da mem\u00f3ria para exibir o que desejar e variar a frequ\u00eacia at\u00e9 encontrar uma que seja poss\u00edvel ver o banner. </p> <p></p>"},{"location":"labs/02-decode-game/","title":"Decodificando instru\u00e7\u00f5es do RISC-V","text":"<p>O objetivo desta pr\u00e1tica \u00e9 construir um jogo para compreender a codifica\u00e7\u00e3o de instru\u00e7\u00f5es e c\u00e1lculos de endere\u00e7o no RISC-V. Ele pode ser feito em qualquer linguagem de sua prefer\u00eancia, usando ou n\u00e3o o kit de FPGAs. A partir de um programa fornecido ou gerado aleat\u00f3riamente, o jogador precisa adivinhar partes das instru\u00e7\u00f5es ou endere\u00e7os para ganhar pontos ou avan\u00e7ar no jogo. A seguir est\u00e1 um fluxo poss\u00edvel: </p> <pre><code>flowchart TD\n    Start([\"Escolha Instru\u00e7\u00e3o\"])\n    Opcode[\"Adivinhar OPCODE (7 bits)\"]\n    Format{\"Formato?\"}\n    NextInstr([\"Pr\u00f3xima Instru\u00e7\u00e3o\"])\n\n    Start --&gt; Opcode\n    Opcode --&gt; Format\n\n    %% R-Type\n    Format --&gt; RType([\"R-Type\"])\n    RType --&gt; R_rd[\"Adivinhar rd (5)\"]\n    R_rd --&gt; R_funct3[\"Adivinhar funct3 (3)\"]\n    R_funct3 --&gt; R_rs1[\"Adivinhar rs1 (5)\"]\n    R_rs1 --&gt; R_rs2[\"Adivinhar rs2 (5)\"]\n    R_rs2 --&gt; R_funct7[\"Adivinhar funct7 (7)\"]\n    R_funct7 --&gt; NextInstr\n\n    %% I-Type\n    Format --&gt; IType([\"I-Type\"])\n    IType --&gt; I_rd[\"Adivinhar rd (5)\"]\n    I_rd --&gt; I_funct3[\"Adivinhar funct3 (3)\"]\n    I_funct3 --&gt; I_rs1[\"Adivinhar rs1 (5)\"]\n    I_rs1 --&gt; I_imm[\"Adivinhar imm (12)\"]\n    I_imm --&gt; NextInstr\n\n    %% S-Type\n    Format --&gt; SType([\"S-Type\"])\n    SType --&gt; S_funct3[\"Adivinhar funct3 (3)\"]\n    S_funct3 --&gt; S_rs1[\"Adivinhar rs1 (5)\"]\n    S_rs1 --&gt; S_rs2[\"Adivinhar rs2 (5)\"]\n    S_rs2 --&gt; S_imm[\"Adivinhar imm (12, encoded)\"]\n    S_imm --&gt; NextInstr\n\n    %% B-Type\n    Format --&gt; BType([\"B-Type\"])\n    BType --&gt; B_funct3[\"Adivinhar funct3 (3)\"]\n    B_funct3 --&gt; B_rs1[\"Adivinhar rs1 (5)\"]\n    B_rs1 --&gt; B_rs2[\"Adivinhar rs2 (5)\"]\n    B_rs2 --&gt; B_imm[\"Adivinhar imm (13, encoded)\"]\n    B_imm --&gt; NextInstr\n\n    %% U-Type\n    Format --&gt; UType([\"U-Type\"])\n    UType --&gt; U_rd[\"Adivinhar rd (5)\"]\n    U_rd --&gt; U_imm[\"Adivinhar imm (20)\"]\n    U_imm --&gt; NextInstr\n\n    %% J-Type\n    Format --&gt; JType([\"J-Type\"])\n    JType --&gt; J_rd[\"Adivinhar rd (5)\"]\n    J_rd --&gt; J_imm[\"Adivinhar imm (21, encoded)\"]\n    J_imm --&gt; NextInstr\n\n    %% STYLE DEFINITIONS\nclassDef Adivinhar fill:#cce5ff,stroke:#004085,stroke-width:2px;\n    class Opcode,R_rd,R_funct3,R_rs1,R_rs2,R_funct7,I_rd,I_funct3,I_rs1,I_imm,S_funct3,S_rs1,S_rs2,S_imm,B_funct3,B_rs1,B_rs2,B_imm,U_rd,U_imm,J_rd,J_imm Adivinhar;\n</code></pre> <p>Todas as jogadas devem ser informadas em bin\u00e1rio na console!</p> <p>Procure usar programas com instru\u00e7\u00f5es bem diversas, por exemplo:</p> <pre><code>_start:\n    # R-type: registradores\n    add     x5, x1, x2         # R: rd=x5, rs1=x1, rs2=x2, funct3=000, funct7=0000000\n    xor     x4, x2, x3         # R: rd=x4, rs1=x2, rs2=x3, funct3=100, funct7=0000000\n    # I-type (aritm\u00e9tico imediato)\n    addi    x6, x5, 42         # I: rd=x6, rs1=x5, imm=42, funct3=000\n    slli    x5, x6, 3          # I: rd=x5, rs1=x6, shamt=3, funct3=001\n    # I-type (load)\n    lw      x7, 64(x6)          # I: rd=x7, rs1=x6, imm=64, funct3=010\n    lbu     x5, 32(x4)          # I: rd=x5, rs1=x4, imm=32, funct3=100\n    # S-type: store\n    sw      x7, 16(x5)         # S: rs1=x5, rs2=x7, imm=16, funct3=010\n    sb      x6, 16(x2)         # S: rs1=x2, rs2=x6, imm=16, funct3=001\n    # B-type: branch condicional\n    beq     x5, x6, label      # B: rs1=x5, rs2=x6, imm=offset(label), funct3=000\n    bne     x3, x4, label      # B: rs1=x3, rs2=x4, imm=offset(label), funct3=001\n    # U-type: imediato alto\n    lui     x8, 0xABCDE        # U: rd=x8, imm[31:12]=0xABCDE\n    # J-type: salto\n    jal     x1, end            # J: rd=x1 (ra), imm=offset(end)\nlabel:\n    addi    x9, x0, 7          # I: instru\u00e7\u00e3o ap\u00f3s branch\nend:\n    nop                        # I-type: addi x0,x0,0\n</code></pre> <p>Para garantir que as codifica\u00e7\u00f5es est\u00e3o corretas, seu programa deve invocar o GCC para ger\u00e1-la automaticamente. </p> <p>Depois voc\u00ea pode extrair os campos e gerar tabelas como a seguinte:</p> Instr. Opcode rd funct3 rs1 rs2 funct7 imm (decimal/hex) xor x5,x1,x2 0110011 5 100 1 2 0000000 - slli x6,x5,3 0010011 6 001 5 - 0000000 shamt=3 lbu x7,8(x6) 0000011 7 100 6 - - 8 sb x7,16(x5) 0100011 - 001 5 7 - 16 bne x5,x6,label 1100011 - 001 5 6 - offset(label)=calculado lui x8,0xABCDE 0110111 8 - - - - 0xABCDE jal x1,end 1101111 1 - - - - offset(end)=calculado addi x9,x0,7 0010011 9 000 0 - - 7 nop 0010011 0 000 0 - - 0 <p>O jogo deve executar em sistemas Linux apenas no modo console. Incluir coment\u00e1rios no c\u00f3digo fonte e depend\u00eancias necess\u00e1rias para sua execu\u00e7\u00e3o. </p> <p>Um programa de refer\u00eancia foi fornecido, observe os arquivos que ele manipula para entender cada passo. Para test\u00e1-lo, basta digitar <code>make</code> no terminal. </p>"},{"location":"labs/02-decode-game/#referencias","title":"Refer\u00eancias:","text":"<ul> <li>The RISC-V Instruction Set Manual Volume I: Unprivileged ISA, pg. 608</li> <li>From Blinker to RISC-V</li> </ul>"},{"location":"labs/04-riscv-alu/","title":"Escrevendo a ULA do RISC-V","text":"<p>O objetivo desta pr\u00e1tica \u00e9 escrever uma ULA e seu respectivo test bench para o processador RISC-V baseada neste modelo. Utilize o processador de refer\u00eancia e tamb\u00e9m suas refer\u00eancias como modelo. Insira a fun\u00e7\u00e3o <code>$monitor</code> em seus c\u00f3digos, para obter valores reais de suas entradas/sa\u00eddas como as seguintes:</p> <pre><code>PC=00000114 instr=fff28293 funct3=000 aluIn1=00000d93 aluIn2=ffffffff aluOut=00000d92\nPC=00000114 instr=fe029ee3 funct3=001 aluIn1=00000d93 aluIn2=00000000 aluOut=00000d93\nPC=00000114 instr=fe029ee3 funct3=001 aluIn1=00000d92 aluIn2=00000000 aluOut=00000d92\nPC=00000110 instr=fe029ee3 funct3=001 aluIn1=00000d92 aluIn2=00000000 aluOut=00000d92\nPC=00000110 instr=fff28293 funct3=000 aluIn1=00000d92 aluIn2=ffffffff aluOut=00000d91\nPC=00000114 instr=fff28293 funct3=000 aluIn1=00000d92 aluIn2=ffffffff aluOut=00000d91\nPC=00000114 instr=fe029ee3 funct3=001 aluIn1=00000d92 aluIn2=00000000 aluOut=00000d92\nPC=00000114 instr=fe029ee3 funct3=001 aluIn1=00000d91 aluIn2=00000000 aluOut=00000d91\nPC=00000110 instr=fe029ee3 funct3=001 aluIn1=00000d91 aluIn2=00000000 aluOut=00000d91\nPC=00000110 instr=fff28293 funct3=000 aluIn1=00000d91 aluIn2=ffffffff aluOut=00000d90\nPC=00000114 instr=fff28293 funct3=000 aluIn1=00000d91 aluIn2=ffffffff aluOut=00000d90\nPC=00000114 instr=fe029ee3 funct3=001 aluIn1=00000d91 aluIn2=00000000 aluOut=00000d91\n</code></pre>"},{"location":"labs/04-riscv-alu/#entrega","title":"Entrega","text":"<p>Fa\u00e7a commit do seu c\u00f3digo no reposit\u00f3rio do grupo contendo um script <code>run.sh</code> na raiz que gere um sa\u00edda com todas as opera\u00e7\u00f5es v\u00e1lidas da ULA. Inclua no espa\u00e7o abaixo a sa\u00edda gerada e comente os resultados. Como voc\u00ea n\u00e3o tem o processador completo ainda, sugiro usar os dados das simula\u00e7\u00f5es de outros processadores para gerar um arquivo de testes (e.g. <code>values.tv</code>).</p>"},{"location":"labs/04-riscv-alu/#referencias","title":"Refer\u00eancias","text":"<ul> <li>LigthRISCV </li> </ul>"},{"location":"labs/06-riscv-mono-leds/","title":"Testando seu RISC-V monociclo na placa","text":"<p>O objetivo desta pr\u00e1tica \u00e9 testar diretamente no kit de FPGA o processador que voc\u00ea desenvolveu na simula\u00e7\u00e3o desta semana. Para isso, foi implementado externamente (no SoC<sup>1</sup>) um esquema de E/S mapeados em mem\u00f3ria. Para possibilitar o monociclo, separamos as mem\u00f3rias de instru\u00e7\u00f5es e de dados:</p> <pre><code>  // microprocessor\n  riscvmono cpu(clk, reset, pc, instr, addr, writedata, memwrite, readdata);\n\n  // instructions memory \n  rom instr_mem(pc, instr);\n\n  // data memory \n  ram data_mem(clk, memwrite &amp; isRAM, addr, writedata, readdata);\n</code></pre> <p>A mem\u00f3ria de instru\u00e7\u00f5es \u00e9 uma ROM que recebe o PC e retornar a instru\u00e7\u00e3o correspondente ao endere\u00e7o. J\u00e1 a de dados \u00e9 uma RAM que armazena os dados do programa, que podem ser lidos (<code>lw</code>) ou escritos (<code>sw</code>). Cada uma delas possui apenas 256 posi\u00e7\u00f5es, ou seja, podem ser endere\u00e7adas a partir de um \u00fanico byte. </p> <p>O esquema de E/S mapeado em mem\u00f3ria \u00e9 apresentado a seguir:</p> <pre><code>  // memory-mapped i/o\n  wire isIO  = addr[8]; // 0x0000_0100\n  wire isRAM = !isIO;\n  localparam IO_LEDS_bit = 2; // 0x0000_0104\n  localparam IO_HEX_bit  = 3; // 0x0000_0108\n  reg [23:0] hex_digits; // memory-mapped I/O register for HEX\n  dec9segs hex0(hex_digits[ 3: 0], HEX0);\n  dec9segs hex1(hex_digits[ 7: 4], HEX1);\n  dec9segs hex2(hex_digits[11: 8], HEX2);\n  dec9segs hex3(hex_digits[15:12], HEX3);\n  dec9segs hex4(hex_digits[19:16], HEX4);\n  dec9segs hex5(hex_digits[23:20], HEX5);\n  always @(posedge clk)\n    if (memwrite &amp; isIO) begin // I/O write \n      if (addr[IO_LEDS_bit])\n        LEDR &lt;= writedata;\n      if (addr[IO_HEX_bit])\n        hex_digits &lt;= writedata;\n  end\n</code></pre> <ol> <li> <p>SoC significa System on Chip. No contexto deste projeto ele se refere ao arquivo top level para s\u00edntese, que cont\u00e9m a CPU, mem\u00f3rias de instru\u00e7\u00f5es e de dados, al\u00e9m dos perif\u00e9ricos, neste caso os LEDs e displays de sete segmentos.\u00a0\u21a9</p> </li> </ol>"},{"location":"labs/08-riscv-multi-buttons/","title":"Testando seu RISC-V multiciclo na placa","text":"<p>O objetivo desta pr\u00e1tica \u00e9 testar diretamente no kit de FPGA o processador que voc\u00ea desenvolveu na simula\u00e7\u00e3o desta semana. Aproveite o <code>Makefile</code> fornecido l\u00e1 para gerar automaticamente o conte\u00fado da mem\u00f3ria a partir do c\u00f3digo assembly. No processador multiciclo, podemos usar a mesma mem\u00f3ria para instru\u00e7\u00f5es e dados:</p> <pre><code>  // microprocessor\n  riscvmulti cpu(clk, reset, addr, writedata, memwrite, readdata);\n\n  // memory \n  mem ram(clk, memwrite, addr, writedata, MEM_readdata);\n</code></pre> <p>O esquema de E/S mapeado em mem\u00f3ria, fornecido anteriormente, deve ser alterado da seguinte forma para suportar a leitura dos bot\u00f5es da placa:</p> <pre><code>  // memory-mapped i/o\n  wire isIO  = addr[8]; // 0x0000_0100\n  wire isRAM = !isIO;\n  localparam IO_LEDS_bit = 2; // 0x0000_0104\n  localparam IO_HEX_bit  = 3; // 0x0000_0108\n  localparam IO_KEY_bit  = 4; // 0x0000_0110 \n  localparam IO_SW_bit   = 5; // 0x0000_0120\n  reg [23:0] hex_digits; // memory-mapped I/O register for HEX\n  dec7seg hex0(hex_digits[ 3: 0], HEX0);\n  dec7seg hex1(hex_digits[ 7: 4], HEX1);\n  dec7seg hex2(hex_digits[11: 8], HEX2);\n  dec7seg hex3(hex_digits[15:12], HEX3);\n  dec7seg hex4(hex_digits[19:16], HEX4);\n  dec7seg hex5(hex_digits[23:20], HEX5);\n  always @(posedge clk)\n    if (memwrite &amp; isIO) begin // I/O write \n      if (addr[IO_LEDS_bit])\n        LEDR &lt;= writedata;\n      if (addr[IO_HEX_bit])\n        hex_digits &lt;= writedata;\n  end\n  assign IO_readdata = addr[IO_KEY_bit] ? {32'b0, KEY} :\n                       addr[ IO_SW_bit] ? {32'b0,  SW} : \n                                           32'b0       ;\n  assign readdata = isIO ? IO_readdata : MEM_readdata; \n</code></pre> <p>Aproveite o test bench do laborat\u00f3rio anterior para testar o seu software/hardware antes de programar na placa.</p>"},{"location":"labs/10-riscv-multi-vga-lbsb/","title":"RISC-V multiciclo com v\u00eddeo VGA","text":"<p>O objetivo desta pr\u00e1tica \u00e9 adicionar instru\u00e7\u00f5es de manipula\u00e7\u00e3o de bytes ao processor RISC-V multiciclo. Estamos usando um gerador de v\u00eddeo no padr\u00e3o VGA que calcula um endere\u00e7o de mem\u00f3ria e busca dados em um frame buffer para apresentar na tela. O <code>Makefile</code> desta pasta processa o arquivo <code>riscv.asm</code>, gera o arquivo <code>.hex</code> para  a mem\u00f3ria e faz a simula\u00e7\u00e3o, enquanto o da pasta superior pode ser usado para programar a placa. </p> <p>O comando <code>make &amp;&amp; make -f ../Makefile clean program</code> faz, portanto, as duas coisas.  </p> <p>Para economizar recursos, a resolu\u00e7\u00e3o real de 640x480 \u00e9 mapeada na mem\u00f3ria com 20x15, onde cada byte tem o formato XXRRGGBB e representa um quadrado de 32x32 pixels na tela. Isso requer 300 bytes ou 75 palavras, pouco mais que 1/4 da nossa mem\u00f3ria. Vejamos algumas partes relevantes do nosso c\u00f3digo:</p> <pre><code>  // power-on reset\n  power_on_reset por(clk, reset);\n\n  // microprocessor\n  riscvmulti cpu(clk, reset, addr, writedata, memwrite, readdata);\n\n  // memory \n  mem ram(clk, memwrite, addr, writedata, readdata, 'h200 + vaddr, vdata);\n\n  // VGA controller\n  vga gpu(VGA_CLK, reset, VGA_HS, VGA_VS, VGA_DA, vaddr);\n</code></pre> <p>Adicionamos um <code>reset</code> para facilitar a simula\u00e7\u00e3o e garantir o estado inicial dos contadores e endere\u00e7os. O processador continua acessando a mem\u00f3ria normalmente, mas esta agora possui duas portas adicionais: (i) <code>vaddr</code> (gerado no m\u00f3dulo <code>vga</code>) que aponta para uma palavra do frame buffer e (ii) <code>vdata</code> que retorna seu respectivo valor. Ela tamb\u00e9m tem agora leitura s\u00edncrona, o que permite que seja mapeada das block RAMs do FPGA, economizando muitos ALMs:</p> <pre><code>module mem (\n  input  logic        clk, we,\n  input  logic [31:0] a, wd,\n  output logic [31:0] rd,\n  input  logic [31:0] va,\n  output logic [31:0] vd);\n\n  logic  [31:0] RAM [0:255];\n\n  // initialize memory with instructions and data\n  initial\n    $readmemh(\"riscv.hex\", RAM);\n\n  // regular port (read/write)\n  always_ff @(posedge clk)\n  begin\n    if (we)\n      RAM[a[31:2]] &lt;= wd;\n    rd &lt;= RAM[a[31:2]];\n  end\n\n  // video port (read only)\n  always_ff @(posedge clk)\n    vd &lt;= RAM[va[31:2]];\nendmodule\n</code></pre> <p>O primeiro c\u00f3digo de exemplo coloca alguns pixels est\u00e1ticos na tela. Note que, em rela\u00e7\u00e3o \u00e0 declara\u00e7\u00e3o, a palavra \u00e9  mostrada invertida na tela:</p> <pre><code>.data   # 0x00000080 \nframe_buffer: # wrgb, bcmy, gray, ... \n    .word 0xff300c03, 0x000f333c, 0xaaaaaaaa, 0x000f333c, 0xff300c03\n    .space 300-40\n    .word 0xff300c03, 0x000f333c, 0xaaaaaaaa, 0x000f333c, 0xff300c03\nframe_end:\n</code></pre> <p>De certa forma, isso tem rela\u00e7\u00e3o com o Endianess da arquitetura. O RISC-V adota em geral a abordagem Little-endian. </p> <p></p> <p>Os recursos ocupados no kit DE0_CV s\u00e3o os seguintes (zeros omitidos):</p> <pre><code>Fitter Status : Successful - Wed Nov  5 10:11:34 2025\nQuartus Prime Version : 22.1std.2 Build 922 07/20/2023 SC Lite Edition\nRevision Name : project\nTop-level Entity Name : top\nFamily : Cyclone V\nDevice : 5CEBA4F23C7\nTiming Models : Final\nLogic utilization (in ALMs) : 454 / 18,480 ( 2 % )\nTotal registers : 350\nTotal pins : 92 / 224 ( 41 % )\nTotal block memory bits : 16,384 / 3,153,920 ( &lt; 1 % )\nTotal RAM Blocks : 4 / 308 ( 1 % )\n</code></pre>"},{"location":"labs/12-riscv-pipeline/","title":"RISC-V pipeline (5 est\u00e1gios)","text":"<p>O objetivo desta pr\u00e1tica \u00e9 melhorar o processor desenvolvido na \u00faltima simula\u00e7\u00e3o, rodar um benchmark ou aplica\u00e7\u00e3o real e comparar o desempenho, bem como os recursos ocupados no FPGA. A seguir est\u00e1 um exemplo do arquivo <code>project.fit.summary</code> que pode ser consultado para tal: </p> <pre><code>Fitter Status : Successful - Wed Nov  5 10:11:34 2025\nQuartus Prime Version : 22.1std.2 Build 922 07/20/2023 SC Lite Edition\nRevision Name : project\nTop-level Entity Name : top\nFamily : Cyclone V\nDevice : 5CEBA4F23C7\nTiming Models : Final\nLogic utilization (in ALMs) : 454 / 18,480 ( 2 % )\nTotal registers : 350\nTotal pins : 92 / 224 ( 41 % )\nTotal block memory bits : 16,384 / 3,153,920 ( &lt; 1 % )\nTotal RAM Blocks : 4 / 308 ( 1 % )\n</code></pre> <p>Cada grupo deve informar previamente o que deseja fazer no f\u00f3rum da disciplina, ainda que mudan\u00e7as possam ser negociadas posteriormente. </p>"},{"location":"sim/","title":"Simula\u00e7\u00f5es no GitHub","text":"<p>Nesta pasta est\u00e3o simula\u00e7\u00f5es que podem ser feitas em ambiente Linux ou no GitHub Codespaces. As turmas da disciplina precisam entregar as simula\u00e7\u00f5es a partir do GitHub Classroom usando os links postados no AVA. </p> <p>Casa simula\u00e7\u00e3o possui um script <code>setup.sh</code> para instalar o simulador, mas ele s\u00f3 precisa ser executado uma \u00fanica vez em cada ambiente. O script <code>run.sh</code> pode ser usado para conferir se os resultados est\u00e3o corretos, antes de fazer o <code>commit</code> para entrega. Em cada simula\u00e7\u00e3o, as pastas <code>.github</code> e <code>tests</code> s\u00e3o protegidas e n\u00e3o podem ser alteradas, sob pena de zerar a nota do exerc\u00edcio. </p>"},{"location":"sim/00-getting-stated-asm/","title":"Tutorial b\u00e1sico para as simula\u00e7\u00f5es (TL;DR)","text":"<p>As simula\u00e7\u00f5es desta disciplina s\u00e3o entregues diretamente no GitHub e possuem corre\u00e7\u00e3o autom\u00e1tica. </p> <p>\u26a0\ufe0f Fique atento ao prazo de entrega de cada uma delas, pois ap\u00f3s a importa\u00e7\u00e3o das notas ao ambiente da disciplina a atividade atrasada n\u00e3o ser\u00e1 contabilizada no c\u00e1lculo da nota. </p>"},{"location":"sim/00-getting-stated-asm/#como-fazer-usando-o-navegador-l4m3r","title":"Como fazer usando o navegador (l4m3r)","text":"<p>Este v\u00eddeo foi feito para outra disciplina, mas o procedimento das entregas \u00e9 o mesmo, alterando-se apenas os arquivo a serem editados e/ou entregues. </p> <p></p>"},{"location":"sim/00-getting-stated-asm/#como-fazer-usando-o-terminal-1337","title":"Como fazer usando o terminal (1337)","text":"<pre><code># Criar uma conta no GitHub, entrar na turma e aceitar a tarefa\ngit clone https://github.com/DC-UFSCar/mm-2025s2-getting-started-asm-USERNAME # trocando USERNAME pelo seu usu\u00e1rio\ncd mm-2025s2-getting-started-asm-USERNAME # idem\n# Editar os arquivos necess\u00e1rios no seu editor favorito (vim &gt; emacs)\nmake NOMEARQUIVO # usado para compilar e rodar qualquer arquivo (para entrega ou n\u00e3o)\ngit status # lista os arquivos modificados\ngit diff # ver o que foi modificado \ngit add hello.s # adiciona o(s) arquivo(s) modificado(s) ao commit para entrega\ngit commit -m \"well done!\" # usar uma mensagem que descreva bem o que voc\u00ea fez NESTE commit\ngit push # envia para o reposit\u00f3rio remoto para corre\u00e7\u00e3o autom\u00e1tica\n# Pronto! Sua simula\u00e7\u00e3o foi entregue e ser\u00e1 corrigida automaticamente\n</code></pre> <p>\ud83d\udea8 Voc\u00ea s\u00f3 deve alterar os arquivos que est\u00e3o na ra\u00edz do reposit\u00f3rio. A altera\u00e7\u00e3o de arquivos em outras pastas \u00e9 detectada ap\u00f3s a entrega e poder\u00e1 invalidar sua atividade. </p> <p>O conte\u00fado a seguir \u00e9 um tutorial do GitHub do qual este reposit\u00f3rio \u00e9 um fork.</p>"},{"location":"sim/00-getting-stated-asm/#the-basics-of-github","title":"The Basics of GitHub","text":""},{"location":"sim/00-getting-stated-asm/#course-overview-and-learning-outcomes","title":"\ud83e\udd13 Course overview and learning outcomes","text":"<p>The goal of this course is to give you a brief introduction to GitHub. We\u2019ll also provide you with materials for further learning and a few ideas to get you started on our platform. \ud83d\ude80</p>"},{"location":"sim/00-getting-stated-asm/#octocat-git-and-github","title":":octocat: Git and GitHub","text":"<p>Git is a distributed Version Control System (VCS), which means it is a useful tool for easily tracking changes to your code, collaborating, and sharing. With Git you can track the changes you make to your project so you always have a record of what you\u2019ve worked on and can easily revert back to an older version if need be. It also makes working with others easier\u2014groups of people can work together on the same project and merge their changes into one final source!</p> <p>GitHub is a way to use the same power of Git all online with an easy-to-use interface. It\u2019s used across the software world and beyond to collaborate and maintain the history of projects.</p> <p>GitHub is home to some of the most advanced technologies in the world. Whether you're visualizing data or building a new game, there's a whole community and set of tools on GitHub that can get you to the next step. This course starts with the basics of GitHub, but we'll dig into the rest later.</p>"},{"location":"sim/00-getting-stated-asm/#octocat-understanding-the-github-flow","title":":octocat: Understanding the GitHub flow","text":"<p>The GitHub flow is a lightweight workflow that allows you to experiment and collaborate on your projects easily, without the risk of losing your previous work.</p>"},{"location":"sim/00-getting-stated-asm/#repositories","title":"Repositories","text":"<p>A repository is where your project work happens--think of it as your project folder. It contains all of your project\u2019s files and revision history.  You can work within a repository alone or invite others to collaborate with you on those files.</p>"},{"location":"sim/00-getting-stated-asm/#cloning","title":"Cloning","text":"<p>When a repository is created with GitHub, it\u2019s stored remotely in the \u2601\ufe0f. You can clone a repository to create a local copy on your computer and then use Git to sync the two. This makes it easier to fix issues, add or remove files, and push larger commits. You can also use the editing tool of your choice as opposed to the GitHub UI. Cloning a repository also pulls down all the repository data that GitHub has at that point in time, including all versions of every file and folder for the project! This can be helpful if you experiment with your project and then realize you liked a previous version more.  To learn more about cloning, read \"Cloning a Repository\". </p>"},{"location":"sim/00-getting-stated-asm/#committing-and-pushing","title":"Committing and pushing","text":"<p>Committing and pushing are how you can add the changes you made on your local machine to the remote repository in GitHub. That way your instructor and/or teammates can see your latest work when you\u2019re ready to share it. You can make a commit when you have made changes to your project that you want to \u201ccheckpoint.\u201d You can also add a helpful commit message to remind yourself or your teammates what work you did (e.g. \u201cAdded a README with information about our project\u201d).</p> <p>Once you have a commit or multiple commits that you\u2019re ready to add to your repository, you can use the push command to add those changes to your remote repository. Committing and pushing may feel new at first, but we promise you\u2019ll get used to it \ud83d\ude42</p>"},{"location":"sim/00-getting-stated-asm/#github-terms-to-know","title":"\ud83d\udcbb GitHub terms to know","text":""},{"location":"sim/00-getting-stated-asm/#repositories_1","title":"Repositories","text":"<p>We mentioned repositories already, they are where your project work happens, but let\u2019s talk a bit more about the details of them! As you work more on GitHub you will have many repositories which may feel confusing at first. Fortunately, your \"GitHub dashboard\" helps to easily navigate to your repositories and see useful information about them. Make sure you\u2019re logged in to see it!</p> <p>Repositories also contain READMEs. You can add a README file to your repository to tell other people why your project is useful, what they can do with your project, and how they can use it. We are using this README to communicate how to learn Git and GitHub with you. \ud83d\ude04  To learn more about repositories read \"Creating, Cloning, and Archiving Repositories and \"About README's\". </p>"},{"location":"sim/00-getting-stated-asm/#branches","title":"Branches","text":"<p>You can use branches on GitHub to isolate work that you do not want merged into your final project just yet. Branches allow you to develop features, fix bugs, or safely experiment with new ideas in a contained area of your repository. Typically, you might create a new branch from the default branch of your repository\u2014main. This makes a new working copy of your repository for you to experiment with. Once your new changes have been reviewed by a teammate, or you are satisfied with them, you can merge your changes into the default branch of your repository. To learn more about branching, read \"About Branches\".</p>"},{"location":"sim/00-getting-stated-asm/#forks","title":"Forks","text":"<p>A fork is another way to copy a repository, but is usually used when you want to contribute to someone else\u2019s project. Forking a repository allows you to freely experiment with changes without affecting the original project and is very popular when contributing to open source software projects! To learn more about forking, read \"Fork a repo\"</p>"},{"location":"sim/00-getting-stated-asm/#pull-requests","title":"Pull requests","text":"<p>When working with branches, you can use a pull request to tell others about the changes you want to make and ask for their feedback. Once a pull request is opened, you can discuss and review the potential changes with collaborators and add more changes if need be. You can add specific people as reviewers of your pull request which shows you want their feedback on your changes! Once a pull request is ready-to-go, it can be merged into your main branch. To learn more about pull requests, read \"About Pull Requests\". </p>"},{"location":"sim/00-getting-stated-asm/#issues","title":"Issues","text":"<p>Issues are a way to track enhancements, tasks, or bugs for your work on GitHub. Issues are a great way to keep track of all the tasks you want to work on for your project and let others know what you plan to work on. You can also use issues to tell a favorite open source project about a bug you found or a feature you think would be great to add!</p> <p>For larger projects, you can keep track of many issues on a project board. GitHub Projects help you organize and prioritize your work and you can read more about them in this \"About Project boards document. You likely won\u2019t need a project board for your assignments, but once you move on to even bigger projects, they\u2019re a great way to organize your team\u2019s work! You can also link together pull requests and issues to show that a fix is in progress and to automatically close the issue when someone merges the pull request. To learn more about issues and linking them to your pull requests, read \"About Issues\". </p>"},{"location":"sim/00-getting-stated-asm/#your-user-profile","title":"Your user profile","text":"<p>Your profile page tells people the story of your work through the repositories you're interested in, the contributions you've made, and the conversations you've had. You can also give the world a unique view into who you are with your profile README. You can use your profile to let future employers know all about you!  To learn more about your user profile and adding and updating your profile README, read \"Managing Your Profile README\". </p>"},{"location":"sim/00-getting-stated-asm/#using-markdown-on-github","title":"Using markdown on GitHub","text":"<p>You might have noticed already, but you can add some fun styling to your issues, pull requests, and files. \"Markdown\" is an easy way to style your issues, pull requests, and files with some simple syntax. This can be helpful to organize your information and make it easier for others to read. You can also drop in gifs and images to help convey your point! To learn more about using GitHub\u2019s flavor of markdown, read \"Basic Writing and Formatting Syntax\". </p>"},{"location":"sim/00-getting-stated-asm/#engaging-with-the-github-community","title":"Engaging with the GitHub community","text":"<p>The GitHub community is vast. There are many types of people who use GitHub in their day to day\u2014students like you, professional developers, hobbyists working on open source projects, and explorers who are just jumping into the world of software development on their own. There are many ways you can interact with the larger GitHub community, but here are three places where you can start. </p>"},{"location":"sim/00-getting-stated-asm/#starring-repositories","title":"Starring repositories","text":"<p>If you find a repository interesting or you want to keep track of it, star it! When you star a repository it\u2019s also used as a signal to surface better recommendations on github.com/explore. If you\u2019d like to get back to your starred repositories you can do so via your user profile.  To learn  more about starring repositories, read \"Saving Repositories with Stars\". </p>"},{"location":"sim/00-getting-stated-asm/#following-users","title":"Following users","text":"<p>You can follow people on GitHub to receive notifications about their activity and discover projects in their communities. When you follow a user, their public GitHub activity will show up on your dashboard so you can see all the cool things they are working on.  To learn more about following users, read \"Following People\".</p>"},{"location":"sim/00-getting-stated-asm/#browsing-github-explore","title":"Browsing GitHub Explore","text":"<p>GitHub Explore is a great place to do just that \u2026 explore  You can find new projects, events, and developers to interact with.</p> <p>You can check out the GitHub Explore website at github.com/explore. The more you interact with GitHub the more tailored your Explore view will be. </p>"},{"location":"sim/00-getting-stated-asm/#optional-next-steps","title":"\ud83d\udcdd Optional next steps","text":"<ul> <li>Open a pull request and let your teacher know that you\u2019ve finished this course.  </li> <li>Create a new markdown file in this repository. Let them know what you learned and what you are still confused about! Experiment with different styles!</li> <li>Create your profile README. Let the world know a little bit more about you! What are you interested in learning? What are you working on? What's your favorite hobby? Learn more about creating your profile README in the document, \"Managing Your Profile README\".</li> <li>Go to your user dashboard and create a new repository. Experiment with the features within that repository to familiarize yourself with them. </li> <li>Let us know what you liked or didn\u2019t like about the content of this course. What would you like to see more of? What would be interesting or helpful to your learning journey? </li> </ul>"},{"location":"sim/00-getting-stated-asm/#resources","title":"\ud83d\udcda  Resources","text":"<ul> <li>A short video explaining what GitHub is </li> <li>Git and GitHub learning resources </li> <li>Understanding the GitHub flow</li> <li>How to use GitHub branches</li> <li>Interactive Git training materials</li> <li>GitHub's Learning Lab</li> <li>Education community forum</li> <li>GitHub community forum</li> </ul>"},{"location":"sim/01-register-memory/","title":"Entendendo o funcionamento das mem\u00f3rias","text":"<p>O objetivo desta simula\u00e7\u00e3o \u00e9 copiar o conte\u00fado de uma mem\u00f3ria para outra. A primeira mem\u00f3ria, descrita em Verilog Comportamental, j\u00e1 vem configurada com um conte\u00fado inicial. J\u00e1 a segunda mem\u00f3ria, descrita em Verilog Estrutural, n\u00e3o tem qualquer valor inicial, pois \u00e9 composta por um arranjo de registradores.</p> <p></p> <p>Instancie as duas mem\u00f3rias, concatenando-as, de forma que a sa\u00edda da primeira seja fornecida \u00e0 segunda, para que seu conte\u00fado seja copiado, conforme a figura. Forne\u00e7a tamb\u00e9m o valor <code>c0000001</code> para a primeira, de forma que todo o seu conte\u00fado seja sobrescrito por este valor ao longo do teste.</p> <p></p>"},{"location":"sim/02-rf-test-bench/","title":"Testando o banco de registradores do RISC-V","text":"<p>O objetivo desta simula\u00e7\u00e3o \u00e9 escrever um test bench para testar o banco de registradores do RISC-V. Ele possui duas portas de leitura (1 e 2) e uma de escrita (3), totalmente independentes. Para fazer as leituras, s\u00e3o informados os endere\u00e7os <code>ra1</code> e <code>ra2</code> (r*ead address) e retornam os valores <code>rd1</code> e <code>rd2</code> (read data) respectivamente. A escrita \u00e9 s\u00edncrona na subida do clk, para a qual \u00e9 necess\u00e1rio informar o endere\u00e7o desejado em <code>wa3</code> (write address), o dado a ser gravado em <code>wd3</code> (write data) e ainda habilitar a escrita <code>we3</code> (write e*nable). Sua descri\u00e7\u00e3o em Verilog est\u00e1 a seguir (note que a quest\u00e3o do registrador <code>$zero</code> \u00e9 tratada nas leituras e n\u00e3o na escrita):</p> <pre><code>module regfile(\n    input clk, we3, \n    input [4:0] ra1, ra2, wa3, \n    input [31:0] wd3, \n    output [31:0] rd1, rd2);\n\n    reg [31:0] rf [0:31];\n\n    always@(posedge clk)\n        if (we3) \n            rf[wa3] &lt;= wd3; \n\n    assign rd1 = (ra1 != 0) ? rf[ra1] : 0;\n    assign rd2 = (ra2 != 0) ? rf[ra2] : 0;\nendmodule\n</code></pre> <p>O teste consiste em escrever uma sequ\u00eancia de palavras fornecida  nos registradores de <code>$x1</code> a <code>$x8</code> e enquanto as l\u00ea de volta, respeitando as seguintes regras: 1. Todos os endere\u00e7os e dados s\u00f3 devem ser modificados nas bordas de descida do <code>clk</code>; 1. O write enable s\u00f3 pode ser ativado durante escritas v\u00e1lidas;  1. Na porta 2 \u00e9 lido o mesmo registrador da escrita (note que o valor troca no momento da subida do <code>clk</code>); 1. Na porta 1 \u00e9 lido o registrador anterior, gravado um ciclo antes (note que o registrador zero j\u00e1 tem o valor definido); 1. Os demais registradores, que n\u00e3o forem escritos, permanecem indefinidos. </p> <p></p> <p>Voc\u00ea pode informar cada est\u00edmulo manualmente ou automatizar com um loop <code>for</code> ou ainda a cada <code>@(negedge clk)</code>. </p>"},{"location":"sim/03-string-asm/","title":"Manipulando strings em assembly do RISC-V","text":"<p>Nesta simula\u00e7\u00e3o, vamos aprender como manipular strings usando o assembly do RISC-V. </p>"},{"location":"sim/03-string-asm/#exemplo","title":"Exemplo","text":"<p>Observe o programa minuscula.s a seguir, criado ler uma string da console, convert\u00ea-la para min\u00fasculas e imprimir o resultado:</p> <pre><code>    .section .data\nbuffer: .space 128        # buffer para leitura (128 bytes m\u00e1x)\n\n    .section .text\n    .globl _start\n_start:\n    # read(0, buffer, 128)\n    li a7, 63             # syscall read\n    li a0, 0              # fd = 0 (stdin)\n    la a1, buffer         # buffer destino\n    li a2, 128            # tamanho m\u00e1x\n    ecall\n    mv s0, a0             # s0 = n\u00famero de bytes lidos (preservar)\n\n    # converter somente letras A\u2013Z em min\u00fasculas\n    la t1, buffer         # t1 = ponteiro para buffer\n    mv t0, s0             # contador de bytes\nloop:\n    beqz t0, done         # se n\u00e3o h\u00e1 mais bytes -&gt; fim\n    lbu t2, 0(t1)         # l\u00ea pr\u00f3ximo byte (unsigned)\n    li t3, 'A'            # 0x41\n    blt t2, t3, skip      # se &lt; 'A' -&gt; ignora\n    li t3, 'Z'            # 0x5A\n    bgt t2, t3, skip      # se &gt; 'Z' -&gt; ignora\n    ori t2, t2, 0x20      # for\u00e7a bit 5 -&gt; min\u00fasculo\n    sb t2, 0(t1)          # grava de volta\nskip:\n    addi t1, t1, 1        # avan\u00e7a ponteiro\n    addi t0, t0, -1       # decrementa contador\n    j loop\n\ndone:\n    # write(1, buffer, nbytes)\n    li a7, 64             # syscall write\n    li a0, 1              # fd = 1 (stdout)\n    la a1, buffer         # endere\u00e7o do buffer\n    mv a2, s0             # n\u00famero de bytes lidos\n    ecall\n    # exit(0)\n    li a7, 93             # syscall exit\n    li a0, 0\n    ecall\n</code></pre> <ul> <li>Na se\u00e7\u00e3o de dados, um \u00fanico buffer de 128 bytes \u00e9 reservado (linhas 1 e 2). </li> <li>O buffer \u00e9 lido usando a <code>syscall read</code> e o tamanho usado \u00e9 salvo em <code>s0</code> (linhas de 8 at\u00e9 13).</li> <li>Antes de entrar no la\u00e7o principal, <code>t1</code> recebe o endere\u00e7o do buffer e <code>t0</code> o n\u00famero de bytes (linhas 16 e 17). No final do la\u00e7o <code>t1</code> \u00e9 incrementado e <code>t0</code> decrementado (linhas 28 e 29).</li> <li>O crit\u00e9rio de parada \u00e9 feito com <code>beqz</code> (linha 19).</li> <li>Apenas as letras mai\u00fasculas e sem acento s\u00e3o consideradas, ent\u00e3o os limites s\u00e3o testados (linhas de 21 a 24). N\u00fameros e caracteres especiais s\u00e3o ignorados por este filtro. </li> <li>O bit 5 do caracter lido \u00e9 setado com <code>ori</code>, pois as min\u00fasculas est\u00e3o exatamente 32 posi\u00e7\u00f5es adiante na tabela ASCII, e o byte \u00e9 ent\u00e3o gravado de volta na mem\u00f3ria (linhas 26). </li> <li>Ap\u00f3s a conclus\u00e3o do la\u00e7o, as syscalls <code>write</code> e <code>exit</code> s\u00e3o chamadas para imprimir o resultado e finalizar o programa respectivamente. </li> </ul>"},{"location":"sim/03-string-asm/#agora-e-a-sua-vez","title":"Agora \u00e9 a sua vez!","text":"<ol> <li>Usando este programa como exemplo, crie um programa em maiuscula.s para fazer o contr\u00e1rio, ou seja, converter para mai\u00fasculas. </li> <li>Crie tamb\u00e9m um programa em inverte.s para inverter a string sem modificar os caracteres. </li> </ol>"},{"location":"sim/04-riscv-alu/","title":"Escrevendo a ULA do RISC-V","text":"<p>O objetivo desta simula\u00e7\u00e3o \u00e9 escrever uma ULA para o processador RISC-V baseada neste modelo. Utilize o processador de refer\u00eancia e tamb\u00e9m suas refer\u00eancias como modelo. Insira a fun\u00e7\u00e3o <code>$monitor</code> em seus c\u00f3digos, para obter valores reais de suas entradas/sa\u00eddas como as seguintes:</p> <pre><code>Time:   0, instr: 01c38333, op1: cafe0000, op2: 0000babe, res: cafebabe\nTime:  10, instr: 40730333, op1: cafe0000, op2: 0000babe, res: cafd4542\nTime:  20, instr: 40730333, op1: cafebabe, op2: cafe0000, res: 0000babe\nTime:  30, instr: 00338313, op1: cafebabe, op2: 00000003, res: cafebac1\nTime:  40, instr: 00338313, op1: cafe0000, op2: 00000003, res: cafe0003\nTime:  50, instr: 01c3e333, op1: cafe0000, op2: 00400000, res: cafe0000\nTime:  60, instr: 01c3e333, op1: cafe0000, op2: 0000babe, res: cafebabe\nTime:  70, instr: 0033e313, op1: cafe0000, op2: 00000003, res: cafe0003\nTime:  80, instr: 01c3c333, op1: cafe0000, op2: 00400000, res: cabe0000\nTime:  90, instr: 01c3c333, op1: cafe0000, op2: 0000babe, res: cafebabe\nTime: 100, instr: 0033c313, op1: cafe0000, op2: 00000003, res: cafe0003\nTime: 110, instr: 01d39333, op1: cafe0000, op2: 00400000, res: cafe0000\nTime: 120, instr: 01d39333, op1: cafe0000, op2: 00000004, res: afe00000\nTime: 130, instr: 00239313, op1: cafe0000, op2: 00000002, res: 2bf80000\nTime: 140, instr: 01d3d333, op1: cafe0000, op2: 00001800, res: cafe0000\nTime: 150, instr: 01d3d333, op1: cafe0000, op2: 00000004, res: 0cafe000\nTime: 160, instr: 0083d313, op1: cafe0000, op2: 00000008, res: 00cafe00\nTime: 170, instr: 41d3d333, op1: cafe0000, op2: 00000000, res: cafe0000\nTime: 180, instr: 41d3d333, op1: cafe0000, op2: 00000004, res: fcafe000\nTime: 190, instr: 4083d313, op1: cafe0000, op2: 00000408, res: ffcafe00\nTime: 200, instr: 00100073, op1: cafe0000, op2: 00000001, res: cafe0001\n</code></pre> <p>Esta sa\u00edda foi obtida com o seguinte programa de teste:</p> <pre><code>.section .text\n.globl main\nmain:\n    li t2, 0xCAFE0000\n    li t3, 0x0000BABE\n    li t4, 0x4\n\n    add t1, t2, t3\n    sub t1, t1, t2\n    addi t1, t2, 0x3\n    or t1, t2, t3\n    ori t1, t2, 0x3\n    xor t1, t2, t3\n    xori t1, t2, 0x3\n    sll t1, t2, t4\n    slli t1, t2, 0x2\n    srl t1, t2, t4\n    srli t1, t2, 0x8\n    sra t1, t2, t4\n    srai t1, t2, 0x8\n\n    ebreak\n</code></pre>"},{"location":"sim/04-riscv-alu/#referencias","title":"Refer\u00eancias","text":"<ul> <li>LigthRISCV </li> </ul>"},{"location":"sim/05-riscv-mono/","title":"Implementa\u00e7\u00e3o de um RISC-V monociclo","text":"<p>O c\u00f3digo fornecido a voc\u00ea nesta simula\u00e7\u00e3o \u00e9 uma implementa\u00e7\u00e3o monociclo do RISC-V, adaptada do c\u00f3digo multiciclo de Bruno Levy <sup>1</sup>. Ele roda, por sua vez, o programa adaptado do LightRISCV <sup>2</sup> para gravar na mem\u00f3ria de dados os primeiros n\u00fameros da sequ\u00eancia de Fibonacci at\u00e9 o limite de 32 bits. </p> <p>Para executar cada instru\u00e7\u00e3o em um \u00fanico ciclo de clock, foi preciso modificar o esquema de von Neumann (dados e instru\u00e7\u00f5es em uma \u00fanica mem\u00f3ria) para o de Harvard, que possui mem\u00f3rias separadas para cada coisa.</p> <p>O c\u00f3digo fornecido est\u00e1 praticamente completo, voc\u00ea s\u00f3 precisa pensar nas perguntas abaixo para fornecer os valores corretos nas atribui\u00e7\u00f5es faltantes: </p> <pre><code>  assign memwrite =     // quando se deve escrever na mem\u00f3ria?\n  assign addr =         // de onde vem o endere\u00e7o de acesso a ela?\n  assign writedata =    // de onde vem o dado que ser\u00e1 escrito?\n\n  wire        writeBackEn =   // quando se deve escrever em registradores?\n  wire [31:0] writeBackData = // de onde vem o dado que ser\u00e1 escrito?\n  wire [31:0] aluIn1 =        // qual \u00e9 o primeiro operando da ula?\n  wire [31:0] aluIn2 =        // qual \u00e9 o segundo operando da ula?\n</code></pre> <p>Algumas delas recebem um \u00fanico sinal, outras precisam de uma fun\u00e7\u00e3o l\u00f3gica entre alguns ou de operadores tern\u00e1rios para decidir entre duas ou mais op\u00e7\u00f5es dependendo do tipo de instru\u00e7\u00e3o. Use o restante do c\u00f3digo que j\u00e1 est\u00e1 pronto para obter os valores necess\u00e1rios e completar estas sete linhas. Voc\u00ea n\u00e3o precisa alterar mais nada al\u00e9m delas, mas fique \u00e0 vontade se quiser propor algo diferente do que lhe foi dado. </p> <p>Nesta simula\u00e7\u00e3o, ao inv\u00e9s de olhar para a sa\u00edda da simula\u00e7\u00e3o e comparar com a sa\u00edda esperada, optou-se por salvar o conte\u00fado final da mem\u00f3ria ap\u00f3s a execu\u00e7\u00e3o. Assim, voc\u00ea pode descomentar e usar livremente o <code>$monitor</code> que est\u00e1 no test bench para depurar o seu c\u00f3digo. H\u00e1 tamb\u00e9m uma op\u00e7\u00e3o comentada para salvar o conte\u00fado do banco de registradores que pode ajudar na depura\u00e7\u00e3o do c\u00f3digo. </p>"},{"location":"sim/05-riscv-mono/#references","title":"References","text":"<ol> <li> <p>From Blinker to RISC-V \u21a9</p> </li> <li> <p>LightRISCV \u21a9</p> </li> </ol>"},{"location":"sim/07-riscv-multi/","title":"Implementa\u00e7\u00e3o de um RISC-V multiciclo","text":"<p>O c\u00f3digo fornecido a voc\u00ea nesta simula\u00e7\u00e3o \u00e9 uma implementa\u00e7\u00e3o multiciclo do RISC-V, adaptada do c\u00f3digo de Bruno Levy <sup>1</sup>. Ele roda, por sua vez, o programa adaptado do LightRISCV <sup>2</sup> para gravar na mem\u00f3ria de dados os primeiros n\u00fameros da sequ\u00eancia de Fibonacci at\u00e9 o limite de 32 bits. </p> <p>Agora usamos o esquema de von Neumann (dados e instru\u00e7\u00f5es em uma \u00fanica mem\u00f3ria). O c\u00f3digo fornecido est\u00e1 praticamente completo, voc\u00ea s\u00f3 precisa pensar nas perguntas abaixo para fornecer os valores corretos nas atribui\u00e7\u00f5es faltantes: </p> <pre><code>    wire writeBackEn = // Quando se escreve no banco de registradores?\n    wire [31:0] writeBackData = // O que se escreve no banco de registradores?\n    wire [31:0] LoadStoreAddress = // Como se calcula o endere\u00e7o de mem\u00f3ria para loads e stores?\n    assign Address = // Qual o endere\u00e7o de mem\u00f3ria a ser acessado? Alternar entre .text e .data dependendo do estado\n    assign MemWrite = // Em que estado se escreve na mem\u00f3ria?\n    assign WriteData = // O que se escreve na mem\u00f3ria?\n</code></pre> <p>Algumas delas recebem um \u00fanico sinal, outras precisam de uma fun\u00e7\u00e3o l\u00f3gica entre alguns ou de operadores tern\u00e1rios para decidir entre duas ou mais op\u00e7\u00f5es dependendo do tipo de instru\u00e7\u00e3o. Use o restante do c\u00f3digo que j\u00e1 est\u00e1 pronto para obter os valores necess\u00e1rios e completar esta meia d\u00fazia de linhas. Voc\u00ea n\u00e3o precisa alterar mais nada al\u00e9m delas, mas fique \u00e0 vontade se quiser propor algo diferente do que lhe foi dado. </p> <p>Nesta simula\u00e7\u00e3o, ao inv\u00e9s de olhar para a sa\u00edda da simula\u00e7\u00e3o e comparar com a sa\u00edda esperada, optou-se por salvar o conte\u00fado final da mem\u00f3ria ap\u00f3s a execu\u00e7\u00e3o. Assim, voc\u00ea pode descomentar e usar livremente o <code>$monitor</code> que est\u00e1 no test bench para depurar o seu c\u00f3digo. H\u00e1 tamb\u00e9m uma op\u00e7\u00e3o comentada para salvar o conte\u00fado do banco de registradores que pode ajudar na depura\u00e7\u00e3o do c\u00f3digo. </p>"},{"location":"sim/07-riscv-multi/#references","title":"References","text":"<ol> <li> <p>From Blinker to RISC-V \u21a9</p> </li> <li> <p>LightRISCV \u21a9</p> </li> </ol>"},{"location":"sim/09-riscv-multi-lbsb/","title":"Implementa\u00e7\u00e3o de um RISC-V multiciclo com instru\u00e7\u00f5es LB/SB","text":"<p>O c\u00f3digo fornecido a voc\u00ea nesta simula\u00e7\u00e3o \u00e9 uma implementa\u00e7\u00e3o multiciclo do RISC-V, adaptada do c\u00f3digo de Bruno Levy <sup>1</sup>. </p> <p>Agora usamos o esquema de von Neumann (dados e instru\u00e7\u00f5es em uma \u00fanica mem\u00f3ria). O c\u00f3digo fornecido est\u00e1 praticamente completo, voc\u00ea s\u00f3 precisa pensar nas perguntas abaixo para fornecer os valores corretos nas atribui\u00e7\u00f5es faltantes (isso j\u00e1 foi feito em uma simula\u00e7\u00e0o anterior): </p> <pre><code>    wire writeBackEn = // Quando se escreve no banco de registradores?\n    wire [31:0] writeBackData = // O que se escreve no banco de registradores?\n    wire [31:0] LoadStoreAddress = // Como se calcula o endere\u00e7o de mem\u00f3ria para loads e stores?\n    assign Address = // Qual o endere\u00e7o de mem\u00f3ria a ser acessado? Alternar entre .text e .data dependendo do estado\n    assign MemWrite = // Em que estado se escreve na mem\u00f3ria?\n    assign WriteData = // O que se escreve na mem\u00f3ria?\n</code></pre> <p>Depois, voc\u00ea precisa notar que o processador s\u00f3 \u00e9 capaz de acessar a mem\u00f3ria com instru\u00e7\u00f5es <code>lw</code> e <code>sw</code>, mas o programa a seguir lhe \u00e9 fornecido:</p> <pre><code>.text   # 0x00000000 \n.globl _start\n_start:\n    la a0, frame_buffer # load address of frame buffer\n    lb t0, 0(a0)        # load first byte\n    lb t1, 1(a0)        # load second byte\n    lb t2, 2(a0)        # load third byte\n    lb t3, 3(a0)        # load fourth byte\n    sb t3, 0(a0)        # store fourth byte to first byte\n    sb t2, 1(a0)        # store third byte to second byte\n    sb t1, 2(a0)        # store second byte to third byte\n    sb t0, 3(a0)        # store first byte to fourth byte\n    ebreak              # end of program    \n\n.data   # 0x00000080 \nframe_buffer: # wrgb, cmy, white\n    .word 0xff300c03, 0x000f333c, 0xaaaaaaaa, 0x000f333c, 0xff300c03\n</code></pre> <p>Voc\u00ea precisa ent\u00e3o completar o processador e a mem\u00f3ria para que ele seja capaz de ler e gravar um byte por vez e tamb\u00e9m meia palavra (half word).</p>"},{"location":"sim/09-riscv-multi-lbsb/#references","title":"References","text":"<ol> <li> <p>From Blinker to RISC-V \u21a9</p> </li> <li> <p>LightRISCV \u21a9</p> </li> </ol>"},{"location":"sim/11-riscv-pipeline/","title":"Implementa\u00e7\u00e3o de um RISC-V pipeline","text":"<p>O c\u00f3digo fornecido a voc\u00ea nesta simula\u00e7\u00e3o \u00e9 uma implementa\u00e7\u00e3o pipeline do RISC-V, adaptada do c\u00f3digo de Bruno Levy <sup>1</sup>. Ele roda, por sua vez, os programas adaptados do nosso livro texto <sup>2</sup> com um pre\u00e2mbulo para inicializar os registradores usados nos exemplos do livro. </p> <p>Na vers\u00e3o pipeline voltamos a usar o esquema de Harvard (dados e instru\u00e7\u00f5es em mem\u00f3rias separadas). O c\u00f3digo fornecido est\u00e1 completo, mas o processador n\u00e3o trata nenhum Hazard, ent\u00e3o voc\u00ea precisa corrigir isso por etapas: </p> <ol> <li>O programa <code>base.asm</code> executa corretamente, pois n\u00e3o h\u00e1 nenhuma depend\u00eancia entre as instru\u00e7\u00f5es; </li> <li>O programa <code>forward.asm</code> precisa que voc\u00ea implemente o encaminhamento, pois h\u00e1 uma depend\u00eancia RAW no registrador <code>s8</code>. Al\u00e9m disso, o banco de registradores precisa suportar leitura/escrita no mesmo ciclo, lendo o valor atualizado. </li> <li>O programa <code>stall.asm</code> precisa que voc\u00ea implemente uma bolha ap\u00f3s o <code>lw</code> quando houver depend\u00eancia do valor gravado, pois isso n\u00e3o pode ser revolvido com encaminhamento, uma vez que o valor vem da mem\u00f3ria. </li> <li>O programa <code>flush.asm</code> precisa que voc\u00ea implemente o descarte das instru\u00e7\u00f5es quando um salto \u00e9 tomado, j\u00e1 que o processador s\u00f3 desvia do est\u00e1gio de execu\u00e7\u00e3o e as instru\u00e7\u00f5es seguintes foram indevidamente carregadas no pipeline. </li> </ol> <p>Nesta simula\u00e7\u00e3o, ao inv\u00e9s de olhar para a sa\u00edda da simula\u00e7\u00e3o e comparar com a sa\u00edda esperada, optou-se por salvar o conte\u00fado final do banco de registradores ap\u00f3s a execu\u00e7\u00e3o. Assim, voc\u00ea pode descomentar e usar livremente o <code>$monitor</code> que est\u00e1 no test bench para depurar o seu c\u00f3digo. </p> <p>Aten\u00e7\u00e3o: se voc\u00ea colocar instru\u00e7\u00f5es <code>nop</code> ap\u00f3s os trechos cr\u00edticos dos programas eles ir\u00e3o executar corretamente. Voc\u00ea pode fazer isso para testar, mas n\u00e3o se esque\u00e7a de restaurar os programas originais, pois eles est\u00e3o na pasta de testes e nenhum arquivo nela pode ser alterado.  </p>"},{"location":"sim/11-riscv-pipeline/#references","title":"References","text":"<ol> <li> <p>From Blinker to RISC-V \u21a9</p> </li> <li> <p>Digital Design and Computer Architecture, RISC-V Edition \u21a9</p> </li> </ol>"}]}